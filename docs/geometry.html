<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>maven_iuvs.geometry API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>maven_iuvs.geometry</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
from datetime import datetime

import cartopy.crs as ccrs
import matplotlib.pyplot as plt
import numpy as np
import shapely.geometry as sgeom
import spiceypy as spice
from astropy.io import fits
from skimage.transform import resize
import pkg_resources

from maven_iuvs.instrument import slit_width_deg
from maven_iuvs.constants import R_Mars_km


def beta_flip(hdul):
    &#34;&#34;&#34;
    Determine the spacecraft orientation and see if the APP is &#34;beta-flipped,&#34; meaning rotated 180 degrees. 
    This compares the instrument x-axis direction to the spacecraft velocity direction in an inertial reference frame, 
    which are either (nearly) parallel or anti-parallel.

    Parameters
    ----------
    hdul : HDUList
        Opened FITS file.

    Returns
    -------
    beta_flipped : bool, str
        Returns bool True of False if orientation can be determined, otherwise returns the string &#34;unknown&#34;.

    &#34;&#34;&#34;

    # get the instrument&#39;s x-direction vector which is parallel to the spacecraft&#39;s motion
    vi = hdul[&#39;spacecraftgeometry&#39;].data[&#39;vx_instrument_inertial&#39;][-1]

    # get the spacecraft&#39;s velocity vector
    vs = hdul[&#39;spacecraftgeometry&#39;].data[&#39;v_spacecraft_rate_inertial&#39;][-1]

    # determine orientation between vectors (if they are aligned or anti-aligned)
    app_sign = np.sign(np.dot(vi, vs))

    # if negative then no beta flipping, if positive then yes beta flipping, otherwise state is unknown
    if app_sign == -1:
        beta_flipped = False
    elif app_sign == 1:
        beta_flipped = True
    else:
        beta_flipped = &#39;unknown&#39;

    # return the result
    return beta_flipped


def haversine(subsolar_latitude, subsolar_longitude, lat_dim=1800, lon_dim=3600):
    &#34;&#34;&#34;
    Calculates surface solar zenith angles from a given subsolar latitude and longitude.

    Parameters
    ----------
    subsolar_latitude : float
        Subsolar latitude position in degrees.
    subsolar_longitude : float
        Subsolar longitude position in degrees.
    lat_dim : int
        Vertical resolution of the map. Defaults to 0.1 degrees (1800 vertical positions).
    lon_dim : int
        Horizontal resolution of the map. Defaults to 0.1 degrees (3600 horizontal positions).

    Returns
    -------
    longitudes : array
        Meshgrid of longitudes in degrees.
    latitudes : array
        Meshgrid of latitudes in degrees.
    solar_zenith_angles : array
        Surface solar zenith angles in degrees.
    &#34;&#34;&#34;

    # convert subsolar position to radians
    subsolar_latitude = np.radians(subsolar_latitude)
    subsolar_longitude = np.radians(subsolar_longitude)

    # calculate cylindrical meshgrid of latitudes and longitudes
    longitudes, latitudes = np.meshgrid(np.linspace(np.radians(-180), np.radians(180), lon_dim),
                                        np.linspace(np.radians(-90), np.radians(90), lat_dim))

    # calculate solar zenith angles using haversine function
    solar_zenith_angles = 2 * np.arcsin(np.sqrt(np.sin(
        (subsolar_latitude - latitudes) / 2) ** 2 + np.cos(latitudes) * np.cos(subsolar_latitude) *
                                                np.sin((subsolar_longitude - longitudes) / 2) ** 2))

    # convert to degrees
    longitudes = np.degrees(longitudes)
    latitudes = np.degrees(latitudes)
    solar_zenith_angles = np.degrees(solar_zenith_angles)

    # return the meshgrids and SZA
    return longitudes, latitudes, solar_zenith_angles


def highres_swath_geometry(hdul, res=200, twilight=&#39;discrete&#39;):
    &#34;&#34;&#34;
    Generates an artificial high-resolution slit, calculates viewing geometry and surface-intercept map.

    Parameters
    ----------
    hdul : HDUList
        Opened FITS file.
    res : int, optional
        The desired number of artificial elements along the slit. Defaults to 200.
    twilight : str
        The appearance of the twilight zone. &#39;discrete&#39; has a partially transparent zone with sharp edges while
        &#39;continuous&#39; smoothes it with a cosine function. The discrete option does not always work on all systems, but
        I cannot yet say why that is. In those cases you get the continuous appearance.

    Returns
    -------
    latitude : array
        Array of latitudes for the centers of each high-resolution artificial pixel. NaNs if pixel doesn&#39;t intercept
        the surface of Mars.
    longitude : array
        Array of longitudes for the centers of each high-resolution artificial pixel. NaNs if pixel doesn&#39;t intercept
        the surface of Mars.
    sza : array
        Array of solar zenith angles for the centers of each high-resolution artificial pixel. NaNs if pixel doesn&#39;t
        intercept the surface of Mars.
    local_time : array
        Array of local times for the centers of each high-resolution artificial pixel. NaNs if pixel doesn&#39;t intercept
        the surface of Mars.
    x : array
        Horizontal coordinate edges in angular space. Has shape (n+1, m+1) for geometry arrays with shape (n,m).
    y : array
        Vertical coordinate edges in angular space. Has shape (n+1, m+1) for geometry arrays with shape (n,m).
    cx : array
        Horizontal coordinate centers in angular space. Same shape as geometry arrays.
    cy : array
        Vertical coordinate centers in angular space. Same shape as geometry arrays.
    context_map : array
        High-resolution image of the Mars surface as intercepted by the swath. RGB tuples with shape (n,m,3).
    &#34;&#34;&#34;

    # calculate beta-flip state
    flipped = beta_flip(hdul)

    # get swath vectors, ephemeris times, and mirror angles
    vec = hdul[&#39;pixelgeometry&#39;].data[&#39;pixel_vec&#39;]
    et = hdul[&#39;integration&#39;].data[&#39;et&#39;]

    # get dimensions of the input data
    n_int = hdul[&#39;integration&#39;].data.shape[0]
    n_spa = len(hdul[&#39;binning&#39;].data[&#39;spapixlo&#39;][0])

    # set the high-resolution slit width and calculate the number of high-resolution integrations
    hifi_spa = res
    hifi_int = int(hifi_spa / n_spa * n_int)

    # make arrays of ephemeris time and array to hold the new swath vector calculations
    et_arr = np.expand_dims(et, 1) * np.ones((n_int, n_spa))
    et_arr = resize(et_arr, (hifi_int, hifi_spa), mode=&#39;edge&#39;)
    vec_arr = np.zeros((hifi_int + 1, hifi_spa + 1, 3))

    # make an artificially-divided slit and create new array of swath vectors
    if flipped:
        lower_left = vec[0, :, 0, 0]
        upper_left = vec[-1, :, 0, 1]
        lower_right = vec[0, :, -1, 2]
        upper_right = vec[-1, :, -1, 3]
    else:
        lower_left = vec[0, :, 0, 1]
        upper_left = vec[-1, :, 0, 0]
        lower_right = vec[0, :, -1, 3]
        upper_right = vec[-1, :, -1, 2]

    for e in range(3):
        a = np.linspace(lower_left[e], upper_left[e], hifi_int + 1)
        b = np.linspace(lower_right[e], upper_right[e], hifi_int + 1)
        vec_arr[:, :, e] = np.array([np.linspace(i, j, hifi_spa + 1) for i, j in zip(a, b)])

    # resize array to extract centers
    vec_arr = resize(vec_arr, (hifi_int, hifi_spa, 3), anti_aliasing=True)

    # make empty arrays to hold geometry calculations
    latitude = np.zeros((hifi_int, hifi_spa))*np.nan
    longitude = np.zeros((hifi_int, hifi_spa))*np.nan
    sza = np.zeros((hifi_int, hifi_spa))*np.nan
    phase_angle = np.zeros((hifi_int, hifi_spa))*np.nan
    emission_angle = np.zeros((hifi_int, hifi_spa))*np.nan
    local_time = np.zeros((hifi_int, hifi_spa))*np.nan
    context_map = np.zeros((hifi_int, hifi_spa, 3))*np.nan

    # load Mars surface map and switch longitude domain from [-180,180) to [0, 360)
    mars_surface_map = plt.imread(os.path.join(pkg_resources.resource_filename(&#39;maven_iuvs&#39;, &#39;ancillary/&#39;),
                                               &#39;mars_surface_map.jpg&#39;))
    offset_map = np.zeros_like(mars_surface_map)
    offset_map[:, :1800, :] = mars_surface_map[:, 1800:, :]
    offset_map[:, 1800:, :] = mars_surface_map[:, :1800, :]
    mars_surface_map = offset_map

    # calculate intercept latitude and longitude using SPICE, looping through each high-resolution pixel
    target = &#39;Mars&#39;
    frame = &#39;IAU_Mars&#39;
    abcorr = &#39;LT+S&#39;
    observer = &#39;MAVEN&#39;
    body = 499  # Mars IAU code

    for i in range(hifi_int):
        for j in range(hifi_spa):
            et = et_arr[i, j]
            los_mid = vec_arr[i, j, :]

            # try to perform the SPICE calculations and record the results
            # noinspection PyBroadException
            try:

                # calculate surface intercept
                spoint, trgepc, srfvec = spice.sincpt(&#39;Ellipsoid&#39;, target, et, frame, abcorr, observer, frame, los_mid)

                # calculate illumination angles
                trgepc, srfvec, phase_for, solar, emissn = spice.ilumin(&#39;Ellipsoid&#39;, target, et, frame, abcorr,
                                                                        observer, spoint)

                # convert from rectangular to spherical coordinates
                rpoint, colatpoint, lonpoint = spice.recsph(spoint)

                # convert longitude from domain [-pi,pi) to [0,2pi)
                if lonpoint &lt; 0.:
                    lonpoint += 2 * np.pi

                # convert ephemeris time to local solar time
                hr, mn, sc, time, ampm = spice.et2lst(et, body, lonpoint, &#39;planetocentric&#39;, timlen=256, ampmlen=256)

                # convert spherical coordinates to latitude and longitude in degrees
                latitude[i, j] = np.degrees(np.pi / 2 - colatpoint)
                longitude[i, j] = np.degrees(lonpoint)

                # convert illumination angles to degrees and record
                sza[i, j] = np.degrees(solar)
                phase_angle[i, j] = np.degrees(phase_for)
                emission_angle[i, j] = np.degrees(emissn)

                # convert local solar time to decimal hour
                local_time[i, j] = hr + mn / 60 + sc / 3600

                # convert latitude and longitude to pixel coordinates
                map_lat = int(np.round(np.degrees(colatpoint), 1) * 10)
                map_lon = int(np.round(np.degrees(lonpoint), 1) * 10)

                # instead of changing an alpha layer, I just multiply an RGB triplet by a scaling fraction in order to
                # make it darker; determine that scalar here based on solar zenith angle
                if twilight == &#39;discrete&#39;:
                    if (sza[i, j] &gt; 90) &amp; (sza[i, j] &lt;= 102):
                        twilight = 0.7
                    elif sza[i, j] &gt; 102:
                        twilight = 0.4
                    else:
                        twilight = 1
                else:
                    if (sza[i, j] &gt; 90) &amp; (sza[i, j] &lt;= 102):
                        tsza = (sza[i, j]-90)*np.pi/2/12
                        twilight = np.cos(tsza)*0.6 + 0.4
                    elif sza[i, j] &gt; 102:
                        twilight = 0.4
                    else:
                        twilight = 1

                # place the corresponding pixel from the high-resolution Mars map into the swath context map with the
                # twilight scaling
                context_map[i, j, :] = mars_surface_map[map_lat, map_lon, :] / 255 * twilight

            # if the SPICE calculation fails, this (probably) means it didn&#39;t intercept the planet
            except:
                pass

    # get mirror angles
    angles = hdul[&#39;integration&#39;].data[&#39;mirror_deg&#39;] * 2  # convert from mirror angles to FOV angles
    dang = np.diff(angles)[0]

    # create an meshgrid of angular coordinates for the high-resolution pixel edges
    x, y = np.meshgrid(np.linspace(0, slit_width_deg, hifi_spa + 1),
                       np.linspace(angles[0] - dang / 2, angles[-1] + dang / 2, hifi_int + 1))

    # calculate the angular separation between pixels
    dslit = slit_width_deg / hifi_spa

    # create an meshgrid of angular coordinates for the high-resolution pixel centers
    cx, cy = np.meshgrid(
        np.linspace(0 + dslit, slit_width_deg - dslit, hifi_spa),
        np.linspace(angles[0], angles[-1], hifi_int))

    # beta-flip the coordinate arrays if necessary
    if flipped:
        x = np.fliplr(x)
        y = (np.fliplr(y) - 90) / (-1) + 90
        cx = np.fliplr(cx)
        cy = (np.fliplr(cy) - 90) / (-1) + 90

    # convert longitude to [-180,180)
    longitude[np.where(longitude &gt; 180)] -= 360

    # return the geometry and coordinate arrays
    return latitude, longitude, sza, local_time, x, y, cx, cy, context_map


def find_maven_apsis(segment=&#39;periapse&#39;):
    &#34;&#34;&#34;
    Calculates the ephemeris times at apoapse or periapse for all MAVEN orbits between orbital insertion and now.
    Requires furnishing of all SPICE kernels.

    Parameters
    ----------
    segment : str
        The orbit point at which to calculate the ephemeris time. Choices are &#39;periapse&#39; and &#39;apoapse&#39;. Defaults to
        &#39;periapse&#39;.

    Returns
    -------
    orbit_numbers : array
        Array of MAVEN orbit numbers.
    et_array : array
        Array of ephemeris times for chosen orbit segment.
    &#34;&#34;&#34;

    # set starting and ending times
    et_start = 464623267  # MAVEN orbital insertion
    et_end = spice.datetime2et(datetime.utcnow())  # right now

    # do very complicated SPICE stuff
    target = &#39;Mars&#39;
    abcorr = &#39;NONE&#39;
    observer = &#39;MAVEN&#39;
    relate = &#39;&#39;
    refval = 0.
    if segment == &#39;periapse&#39;:
        relate = &#39;LOCMIN&#39;
        refval = 3396. + 500.
    elif segment == &#39;apoapse&#39;:
        relate = &#39;LOCMAX&#39;
        refval = 3396. + 6200.
    adjust = 0.
    step = 60.  # 1 minute steps, since we are only looking within periapse segment for periapsis
    et = [et_start, et_end]
    cnfine = spice.utils.support_types.SPICEDOUBLE_CELL(2)
    spice.wninsd(et[0], et[1], cnfine)
    ninterval = round((et[1] - et[0]) / step)
    result = spice.utils.support_types.SPICEDOUBLE_CELL(round(1.1 * (et[1] - et[0]) / 4.5))
    spice.gfdist(target, abcorr, observer, relate, refval, adjust, step, ninterval, cnfine, result=result)
    count = spice.wncard(result)
    et_array = np.zeros(count)
    if count == 0:
        print(&#39;Result window is empty.&#39;)
    else:
        for i in range(count):
            lr = spice.wnfetd(result, i)
            left = lr[0]
            right = lr[1]
            if left == right:
                et_array[i] = left

    # make array of orbit numbers
    orbit_numbers = np.arange(1, len(et_array) + 1, 1, dtype=int)

    # return orbit numbers and array of ephemeris times
    return orbit_numbers, et_array


def spice_positions(et):
    &#34;&#34;&#34;
    Calculates MAVEN spacecraft position, Mars solar longitude, and subsolar position for a given ephemeris time.

    Parameters
    ----------
    et : float
        Input epoch in ephemeris seconds past J2000.

    Returns
    -------
    et : array
        The input ephemeris times. Just givin&#39;em back.
    subsc_lat : array
        Sub-spacecraft latitudes in degrees.
    subsc_lon : array
        Sub-spacecraft longitudes in degrees.
    sc_alt_km : array
        Sub-spacecraft altitudes in kilometers.
    ls : array
        Mars solar longitudes in degrees.
    subsolar_lat : array
        Sub-solar latitudes in degrees.
    subsolar_lon : array
        Sub-solar longitudes in degrees.
    &#34;&#34;&#34;

    # do a bunch of SPICE stuff only Justin understands...
    target = &#39;Mars&#39;
    abcorr = &#39;LT+S&#39;
    observer = &#39;MAVEN&#39;
    spoint, trgepc, srfvec = spice.subpnt(&#39;Intercept: ellipsoid&#39;, target, et, &#39;IAU_MARS&#39;, abcorr, observer)
    rpoint, colatpoint, lonpoint = spice.recsph(spoint)
    if lonpoint &gt; np.pi:
        lonpoint -= 2 * np.pi
    subsc_lat = 90 - np.degrees(colatpoint)
    subsc_lon = np.degrees(lonpoint)
    sc_alt_km = np.sqrt(np.sum(srfvec ** 2))

    # calculate subsolar position
    sspoint, strgepc, ssrfvec = spice.subslr(&#39;Intercept: ellipsoid&#39;, target, et, &#39;IAU_MARS&#39;, abcorr, observer)
    srpoint, scolatpoint, slonpoint = spice.recsph(sspoint)
    if slonpoint &gt; np.pi:
        slonpoint -= 2 * np.pi
    subsolar_lat = 90 - np.degrees(scolatpoint)
    subsolar_lon = np.degrees(slonpoint)

    # calculate solar longitude
    ls = spice.lspcn(target, et, abcorr)
    ls = np.degrees(ls)

    # return the position information
    return et, subsc_lat, subsc_lon, sc_alt_km, ls, subsolar_lat, subsolar_lon


def get_orbit_positions():
    &#34;&#34;&#34;
    Calculates orbit segment geometry information. Includes orbit numbers, ephemeris time, sub-spacecraft latitude,
    longitude, and altitude (in km), and solar longitude for three orbit positions: start, periapse, apoapse.

    Parameters
    ----------
    None.

    Returns
    -------
    orbit_data : dict
        Calculations of the spacecraft and Mars position.
    &#34;&#34;&#34;

    # get ephemeris times for orbit apoapse and periapse points
    orbit_numbers, periapse_et = find_maven_apsis(segment=&#39;periapse&#39;)
    orbit_numbers, apoapse_et = find_maven_apsis(segment=&#39;apoapse&#39;)
    n_orbits = len(orbit_numbers)

    # make arrays to hold information
    et = np.zeros((n_orbits, 3)) * np.nan
    subsc_lat = np.zeros((n_orbits, 3)) * np.nan
    subsc_lon = np.zeros((n_orbits, 3)) * np.nan
    sc_alt_km = np.zeros((n_orbits, 3)) * np.nan
    solar_longitude = np.zeros((n_orbits, 3)) * np.nan
    subsolar_lat = np.zeros((n_orbits, 3)) * np.nan
    subsolar_lon = np.zeros((n_orbits, 3)) * np.nan

    # loop through orbit numbers and calculate positions
    for i in range(n_orbits):

        for j in range(3):

            # first do orbit start positions
            if j == 0:
                tet, tsubsc_lat, tsubsc_lon, tsc_alt_km, tls, tsubsolar_lat, tsubsolar_lon = spice_positions(
                    periapse_et[i] - 1284)

            # then periapse positions
            elif j == 1:
                tet, tsubsc_lat, tsubsc_lon, tsc_alt_km, tls, tsubsolar_lat, tsubsolar_lon = spice_positions(
                    periapse_et[i])

            # and finally apoapse positions
            else:
                tet, tsubsc_lat, tsubsc_lon, tsc_alt_km, tls, tsubsolar_lat, tsubsolar_lon = spice_positions(
                    apoapse_et[i])

            # place calculations into arrays
            et[i, j] = tet
            subsc_lat[i, j] = tsubsc_lat
            subsc_lon[i, j] = tsubsc_lon
            sc_alt_km[i, j] = tsc_alt_km
            solar_longitude[i, j] = tls
            subsolar_lat[i, j] = tsubsolar_lat
            subsolar_lon[i, j] = tsubsolar_lon

    # make a dictionary of the calculations
    orbit_data = {
        &#39;orbit_numbers&#39;: orbit_numbers,
        &#39;et&#39;: et,
        &#39;subsc_lat&#39;: subsc_lat,
        &#39;subsc_lon&#39;: subsc_lon,
        &#39;subsc_alt_km&#39;: sc_alt_km,
        &#39;solar_longitude&#39;: solar_longitude,
        &#39;subsolar_lat&#39;: subsolar_lat,
        &#39;subsolar_lon&#39;: subsolar_lon,
        &#39;position_indices&#39;: np.array([&#39;orbit start (periapse - 21.4 minutes)&#39;, &#39;periapse&#39;, &#39;apoapse&#39;]),
    }

    # return the calculations
    return orbit_data


def rotation_matrix(axis, theta):
    &#34;&#34;&#34;
    Return the rotation matrix associated with counterclockwise rotation about the given axis by theta radians.
    To transform a vector, calculate its dot-product with the rotation matrix.

    Parameters
    ----------
    axis : 3-element list, array, or tuple
        The rotation axis in Cartesian coordinates. Does not have to be a unit vector.
    theta : float
        The angle (in radians) to rotate about the rotation axis. Positive angles rotate counter-clockwise.

    Returns
    -------
    matrix : array
        The 3D rotation matrix with dimensions (3,3).
    &#34;&#34;&#34;

    # convert the axis to a numpy array and normalize it
    axis = np.array(axis)
    axis = axis / np.linalg.norm(axis)

    # calculate components of the rotation matrix elements
    a = np.cos(theta / 2)
    b, c, d = -axis * np.sin(theta / 2)
    aa, bb, cc, dd = a * a, b * b, c * c, d * d
    bc, ad, ac, ab, bd, cd = b * c, a * d, a * c, a * b, b * d, c * d

    # build the rotation matrix
    matrix = np.array([[aa + bb - cc - dd, 2 * (bc + ad), 2 * (bd - ac)],
                       [2 * (bc - ad), aa + cc - bb - dd, 2 * (cd + ab)],
                       [2 * (bd + ac), 2 * (cd - ab), aa + dd - bb - cc]])

    # return the rotation matrix
    return matrix</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="maven_iuvs.geometry.beta_flip"><code class="name flex">
<span>def <span class="ident">beta_flip</span></span>(<span>hdul)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the spacecraft orientation and see if the APP is "beta-flipped," meaning rotated 180 degrees.
This compares the instrument x-axis direction to the spacecraft velocity direction in an inertial reference frame,
which are either (nearly) parallel or anti-parallel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hdul</code></strong> :&ensp;<code>HDUList</code></dt>
<dd>Opened FITS file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>beta_flipped</code></strong> :&ensp;<code>bool, str</code></dt>
<dd>Returns bool True of False if orientation can be determined, otherwise returns the string "unknown".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def beta_flip(hdul):
    &#34;&#34;&#34;
    Determine the spacecraft orientation and see if the APP is &#34;beta-flipped,&#34; meaning rotated 180 degrees. 
    This compares the instrument x-axis direction to the spacecraft velocity direction in an inertial reference frame, 
    which are either (nearly) parallel or anti-parallel.

    Parameters
    ----------
    hdul : HDUList
        Opened FITS file.

    Returns
    -------
    beta_flipped : bool, str
        Returns bool True of False if orientation can be determined, otherwise returns the string &#34;unknown&#34;.

    &#34;&#34;&#34;

    # get the instrument&#39;s x-direction vector which is parallel to the spacecraft&#39;s motion
    vi = hdul[&#39;spacecraftgeometry&#39;].data[&#39;vx_instrument_inertial&#39;][-1]

    # get the spacecraft&#39;s velocity vector
    vs = hdul[&#39;spacecraftgeometry&#39;].data[&#39;v_spacecraft_rate_inertial&#39;][-1]

    # determine orientation between vectors (if they are aligned or anti-aligned)
    app_sign = np.sign(np.dot(vi, vs))

    # if negative then no beta flipping, if positive then yes beta flipping, otherwise state is unknown
    if app_sign == -1:
        beta_flipped = False
    elif app_sign == 1:
        beta_flipped = True
    else:
        beta_flipped = &#39;unknown&#39;

    # return the result
    return beta_flipped</code></pre>
</details>
</dd>
<dt id="maven_iuvs.geometry.find_maven_apsis"><code class="name flex">
<span>def <span class="ident">find_maven_apsis</span></span>(<span>segment='periapse')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the ephemeris times at apoapse or periapse for all MAVEN orbits between orbital insertion and now.
Requires furnishing of all SPICE kernels.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>segment</code></strong> :&ensp;<code>str</code></dt>
<dd>The orbit point at which to calculate the ephemeris time. Choices are 'periapse' and 'apoapse'. Defaults to
'periapse'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>orbit_numbers</code></strong> :&ensp;<code>array</code></dt>
<dd>Array of MAVEN orbit numbers.</dd>
<dt><strong><code>et_array</code></strong> :&ensp;<code>array</code></dt>
<dd>Array of ephemeris times for chosen orbit segment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_maven_apsis(segment=&#39;periapse&#39;):
    &#34;&#34;&#34;
    Calculates the ephemeris times at apoapse or periapse for all MAVEN orbits between orbital insertion and now.
    Requires furnishing of all SPICE kernels.

    Parameters
    ----------
    segment : str
        The orbit point at which to calculate the ephemeris time. Choices are &#39;periapse&#39; and &#39;apoapse&#39;. Defaults to
        &#39;periapse&#39;.

    Returns
    -------
    orbit_numbers : array
        Array of MAVEN orbit numbers.
    et_array : array
        Array of ephemeris times for chosen orbit segment.
    &#34;&#34;&#34;

    # set starting and ending times
    et_start = 464623267  # MAVEN orbital insertion
    et_end = spice.datetime2et(datetime.utcnow())  # right now

    # do very complicated SPICE stuff
    target = &#39;Mars&#39;
    abcorr = &#39;NONE&#39;
    observer = &#39;MAVEN&#39;
    relate = &#39;&#39;
    refval = 0.
    if segment == &#39;periapse&#39;:
        relate = &#39;LOCMIN&#39;
        refval = 3396. + 500.
    elif segment == &#39;apoapse&#39;:
        relate = &#39;LOCMAX&#39;
        refval = 3396. + 6200.
    adjust = 0.
    step = 60.  # 1 minute steps, since we are only looking within periapse segment for periapsis
    et = [et_start, et_end]
    cnfine = spice.utils.support_types.SPICEDOUBLE_CELL(2)
    spice.wninsd(et[0], et[1], cnfine)
    ninterval = round((et[1] - et[0]) / step)
    result = spice.utils.support_types.SPICEDOUBLE_CELL(round(1.1 * (et[1] - et[0]) / 4.5))
    spice.gfdist(target, abcorr, observer, relate, refval, adjust, step, ninterval, cnfine, result=result)
    count = spice.wncard(result)
    et_array = np.zeros(count)
    if count == 0:
        print(&#39;Result window is empty.&#39;)
    else:
        for i in range(count):
            lr = spice.wnfetd(result, i)
            left = lr[0]
            right = lr[1]
            if left == right:
                et_array[i] = left

    # make array of orbit numbers
    orbit_numbers = np.arange(1, len(et_array) + 1, 1, dtype=int)

    # return orbit numbers and array of ephemeris times
    return orbit_numbers, et_array</code></pre>
</details>
</dd>
<dt id="maven_iuvs.geometry.get_orbit_positions"><code class="name flex">
<span>def <span class="ident">get_orbit_positions</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates orbit segment geometry information. Includes orbit numbers, ephemeris time, sub-spacecraft latitude,
longitude, and altitude (in km), and solar longitude for three orbit positions: start, periapse, apoapse.</p>
<h2 id="parameters">Parameters</h2>
<p>None.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>orbit_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Calculations of the spacecraft and Mars position.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_orbit_positions():
    &#34;&#34;&#34;
    Calculates orbit segment geometry information. Includes orbit numbers, ephemeris time, sub-spacecraft latitude,
    longitude, and altitude (in km), and solar longitude for three orbit positions: start, periapse, apoapse.

    Parameters
    ----------
    None.

    Returns
    -------
    orbit_data : dict
        Calculations of the spacecraft and Mars position.
    &#34;&#34;&#34;

    # get ephemeris times for orbit apoapse and periapse points
    orbit_numbers, periapse_et = find_maven_apsis(segment=&#39;periapse&#39;)
    orbit_numbers, apoapse_et = find_maven_apsis(segment=&#39;apoapse&#39;)
    n_orbits = len(orbit_numbers)

    # make arrays to hold information
    et = np.zeros((n_orbits, 3)) * np.nan
    subsc_lat = np.zeros((n_orbits, 3)) * np.nan
    subsc_lon = np.zeros((n_orbits, 3)) * np.nan
    sc_alt_km = np.zeros((n_orbits, 3)) * np.nan
    solar_longitude = np.zeros((n_orbits, 3)) * np.nan
    subsolar_lat = np.zeros((n_orbits, 3)) * np.nan
    subsolar_lon = np.zeros((n_orbits, 3)) * np.nan

    # loop through orbit numbers and calculate positions
    for i in range(n_orbits):

        for j in range(3):

            # first do orbit start positions
            if j == 0:
                tet, tsubsc_lat, tsubsc_lon, tsc_alt_km, tls, tsubsolar_lat, tsubsolar_lon = spice_positions(
                    periapse_et[i] - 1284)

            # then periapse positions
            elif j == 1:
                tet, tsubsc_lat, tsubsc_lon, tsc_alt_km, tls, tsubsolar_lat, tsubsolar_lon = spice_positions(
                    periapse_et[i])

            # and finally apoapse positions
            else:
                tet, tsubsc_lat, tsubsc_lon, tsc_alt_km, tls, tsubsolar_lat, tsubsolar_lon = spice_positions(
                    apoapse_et[i])

            # place calculations into arrays
            et[i, j] = tet
            subsc_lat[i, j] = tsubsc_lat
            subsc_lon[i, j] = tsubsc_lon
            sc_alt_km[i, j] = tsc_alt_km
            solar_longitude[i, j] = tls
            subsolar_lat[i, j] = tsubsolar_lat
            subsolar_lon[i, j] = tsubsolar_lon

    # make a dictionary of the calculations
    orbit_data = {
        &#39;orbit_numbers&#39;: orbit_numbers,
        &#39;et&#39;: et,
        &#39;subsc_lat&#39;: subsc_lat,
        &#39;subsc_lon&#39;: subsc_lon,
        &#39;subsc_alt_km&#39;: sc_alt_km,
        &#39;solar_longitude&#39;: solar_longitude,
        &#39;subsolar_lat&#39;: subsolar_lat,
        &#39;subsolar_lon&#39;: subsolar_lon,
        &#39;position_indices&#39;: np.array([&#39;orbit start (periapse - 21.4 minutes)&#39;, &#39;periapse&#39;, &#39;apoapse&#39;]),
    }

    # return the calculations
    return orbit_data</code></pre>
</details>
</dd>
<dt id="maven_iuvs.geometry.haversine"><code class="name flex">
<span>def <span class="ident">haversine</span></span>(<span>subsolar_latitude, subsolar_longitude, lat_dim=1800, lon_dim=3600)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates surface solar zenith angles from a given subsolar latitude and longitude.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>subsolar_latitude</code></strong> :&ensp;<code>float</code></dt>
<dd>Subsolar latitude position in degrees.</dd>
<dt><strong><code>subsolar_longitude</code></strong> :&ensp;<code>float</code></dt>
<dd>Subsolar longitude position in degrees.</dd>
<dt><strong><code>lat_dim</code></strong> :&ensp;<code>int</code></dt>
<dd>Vertical resolution of the map. Defaults to 0.1 degrees (1800 vertical positions).</dd>
<dt><strong><code>lon_dim</code></strong> :&ensp;<code>int</code></dt>
<dd>Horizontal resolution of the map. Defaults to 0.1 degrees (3600 horizontal positions).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>longitudes</code></strong> :&ensp;<code>array</code></dt>
<dd>Meshgrid of longitudes in degrees.</dd>
<dt><strong><code>latitudes</code></strong> :&ensp;<code>array</code></dt>
<dd>Meshgrid of latitudes in degrees.</dd>
<dt><strong><code>solar_zenith_angles</code></strong> :&ensp;<code>array</code></dt>
<dd>Surface solar zenith angles in degrees.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def haversine(subsolar_latitude, subsolar_longitude, lat_dim=1800, lon_dim=3600):
    &#34;&#34;&#34;
    Calculates surface solar zenith angles from a given subsolar latitude and longitude.

    Parameters
    ----------
    subsolar_latitude : float
        Subsolar latitude position in degrees.
    subsolar_longitude : float
        Subsolar longitude position in degrees.
    lat_dim : int
        Vertical resolution of the map. Defaults to 0.1 degrees (1800 vertical positions).
    lon_dim : int
        Horizontal resolution of the map. Defaults to 0.1 degrees (3600 horizontal positions).

    Returns
    -------
    longitudes : array
        Meshgrid of longitudes in degrees.
    latitudes : array
        Meshgrid of latitudes in degrees.
    solar_zenith_angles : array
        Surface solar zenith angles in degrees.
    &#34;&#34;&#34;

    # convert subsolar position to radians
    subsolar_latitude = np.radians(subsolar_latitude)
    subsolar_longitude = np.radians(subsolar_longitude)

    # calculate cylindrical meshgrid of latitudes and longitudes
    longitudes, latitudes = np.meshgrid(np.linspace(np.radians(-180), np.radians(180), lon_dim),
                                        np.linspace(np.radians(-90), np.radians(90), lat_dim))

    # calculate solar zenith angles using haversine function
    solar_zenith_angles = 2 * np.arcsin(np.sqrt(np.sin(
        (subsolar_latitude - latitudes) / 2) ** 2 + np.cos(latitudes) * np.cos(subsolar_latitude) *
                                                np.sin((subsolar_longitude - longitudes) / 2) ** 2))

    # convert to degrees
    longitudes = np.degrees(longitudes)
    latitudes = np.degrees(latitudes)
    solar_zenith_angles = np.degrees(solar_zenith_angles)

    # return the meshgrids and SZA
    return longitudes, latitudes, solar_zenith_angles</code></pre>
</details>
</dd>
<dt id="maven_iuvs.geometry.highres_swath_geometry"><code class="name flex">
<span>def <span class="ident">highres_swath_geometry</span></span>(<span>hdul, res=200, twilight='discrete')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an artificial high-resolution slit, calculates viewing geometry and surface-intercept map.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hdul</code></strong> :&ensp;<code>HDUList</code></dt>
<dd>Opened FITS file.</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The desired number of artificial elements along the slit. Defaults to 200.</dd>
<dt><strong><code>twilight</code></strong> :&ensp;<code>str</code></dt>
<dd>The appearance of the twilight zone. 'discrete' has a partially transparent zone with sharp edges while
'continuous' smoothes it with a cosine function. The discrete option does not always work on all systems, but
I cannot yet say why that is. In those cases you get the continuous appearance.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>latitude</code></strong> :&ensp;<code>array</code></dt>
<dd>Array of latitudes for the centers of each high-resolution artificial pixel. NaNs if pixel doesn't intercept
the surface of Mars.</dd>
<dt><strong><code>longitude</code></strong> :&ensp;<code>array</code></dt>
<dd>Array of longitudes for the centers of each high-resolution artificial pixel. NaNs if pixel doesn't intercept
the surface of Mars.</dd>
<dt><strong><code>sza</code></strong> :&ensp;<code>array</code></dt>
<dd>Array of solar zenith angles for the centers of each high-resolution artificial pixel. NaNs if pixel doesn't
intercept the surface of Mars.</dd>
<dt><strong><code>local_time</code></strong> :&ensp;<code>array</code></dt>
<dd>Array of local times for the centers of each high-resolution artificial pixel. NaNs if pixel doesn't intercept
the surface of Mars.</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>array</code></dt>
<dd>Horizontal coordinate edges in angular space. Has shape (n+1, m+1) for geometry arrays with shape (n,m).</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code></dt>
<dd>Vertical coordinate edges in angular space. Has shape (n+1, m+1) for geometry arrays with shape (n,m).</dd>
<dt><strong><code>cx</code></strong> :&ensp;<code>array</code></dt>
<dd>Horizontal coordinate centers in angular space. Same shape as geometry arrays.</dd>
<dt><strong><code>cy</code></strong> :&ensp;<code>array</code></dt>
<dd>Vertical coordinate centers in angular space. Same shape as geometry arrays.</dd>
<dt><strong><code>context_map</code></strong> :&ensp;<code>array</code></dt>
<dd>High-resolution image of the Mars surface as intercepted by the swath. RGB tuples with shape (n,m,3).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def highres_swath_geometry(hdul, res=200, twilight=&#39;discrete&#39;):
    &#34;&#34;&#34;
    Generates an artificial high-resolution slit, calculates viewing geometry and surface-intercept map.

    Parameters
    ----------
    hdul : HDUList
        Opened FITS file.
    res : int, optional
        The desired number of artificial elements along the slit. Defaults to 200.
    twilight : str
        The appearance of the twilight zone. &#39;discrete&#39; has a partially transparent zone with sharp edges while
        &#39;continuous&#39; smoothes it with a cosine function. The discrete option does not always work on all systems, but
        I cannot yet say why that is. In those cases you get the continuous appearance.

    Returns
    -------
    latitude : array
        Array of latitudes for the centers of each high-resolution artificial pixel. NaNs if pixel doesn&#39;t intercept
        the surface of Mars.
    longitude : array
        Array of longitudes for the centers of each high-resolution artificial pixel. NaNs if pixel doesn&#39;t intercept
        the surface of Mars.
    sza : array
        Array of solar zenith angles for the centers of each high-resolution artificial pixel. NaNs if pixel doesn&#39;t
        intercept the surface of Mars.
    local_time : array
        Array of local times for the centers of each high-resolution artificial pixel. NaNs if pixel doesn&#39;t intercept
        the surface of Mars.
    x : array
        Horizontal coordinate edges in angular space. Has shape (n+1, m+1) for geometry arrays with shape (n,m).
    y : array
        Vertical coordinate edges in angular space. Has shape (n+1, m+1) for geometry arrays with shape (n,m).
    cx : array
        Horizontal coordinate centers in angular space. Same shape as geometry arrays.
    cy : array
        Vertical coordinate centers in angular space. Same shape as geometry arrays.
    context_map : array
        High-resolution image of the Mars surface as intercepted by the swath. RGB tuples with shape (n,m,3).
    &#34;&#34;&#34;

    # calculate beta-flip state
    flipped = beta_flip(hdul)

    # get swath vectors, ephemeris times, and mirror angles
    vec = hdul[&#39;pixelgeometry&#39;].data[&#39;pixel_vec&#39;]
    et = hdul[&#39;integration&#39;].data[&#39;et&#39;]

    # get dimensions of the input data
    n_int = hdul[&#39;integration&#39;].data.shape[0]
    n_spa = len(hdul[&#39;binning&#39;].data[&#39;spapixlo&#39;][0])

    # set the high-resolution slit width and calculate the number of high-resolution integrations
    hifi_spa = res
    hifi_int = int(hifi_spa / n_spa * n_int)

    # make arrays of ephemeris time and array to hold the new swath vector calculations
    et_arr = np.expand_dims(et, 1) * np.ones((n_int, n_spa))
    et_arr = resize(et_arr, (hifi_int, hifi_spa), mode=&#39;edge&#39;)
    vec_arr = np.zeros((hifi_int + 1, hifi_spa + 1, 3))

    # make an artificially-divided slit and create new array of swath vectors
    if flipped:
        lower_left = vec[0, :, 0, 0]
        upper_left = vec[-1, :, 0, 1]
        lower_right = vec[0, :, -1, 2]
        upper_right = vec[-1, :, -1, 3]
    else:
        lower_left = vec[0, :, 0, 1]
        upper_left = vec[-1, :, 0, 0]
        lower_right = vec[0, :, -1, 3]
        upper_right = vec[-1, :, -1, 2]

    for e in range(3):
        a = np.linspace(lower_left[e], upper_left[e], hifi_int + 1)
        b = np.linspace(lower_right[e], upper_right[e], hifi_int + 1)
        vec_arr[:, :, e] = np.array([np.linspace(i, j, hifi_spa + 1) for i, j in zip(a, b)])

    # resize array to extract centers
    vec_arr = resize(vec_arr, (hifi_int, hifi_spa, 3), anti_aliasing=True)

    # make empty arrays to hold geometry calculations
    latitude = np.zeros((hifi_int, hifi_spa))*np.nan
    longitude = np.zeros((hifi_int, hifi_spa))*np.nan
    sza = np.zeros((hifi_int, hifi_spa))*np.nan
    phase_angle = np.zeros((hifi_int, hifi_spa))*np.nan
    emission_angle = np.zeros((hifi_int, hifi_spa))*np.nan
    local_time = np.zeros((hifi_int, hifi_spa))*np.nan
    context_map = np.zeros((hifi_int, hifi_spa, 3))*np.nan

    # load Mars surface map and switch longitude domain from [-180,180) to [0, 360)
    mars_surface_map = plt.imread(os.path.join(pkg_resources.resource_filename(&#39;maven_iuvs&#39;, &#39;ancillary/&#39;),
                                               &#39;mars_surface_map.jpg&#39;))
    offset_map = np.zeros_like(mars_surface_map)
    offset_map[:, :1800, :] = mars_surface_map[:, 1800:, :]
    offset_map[:, 1800:, :] = mars_surface_map[:, :1800, :]
    mars_surface_map = offset_map

    # calculate intercept latitude and longitude using SPICE, looping through each high-resolution pixel
    target = &#39;Mars&#39;
    frame = &#39;IAU_Mars&#39;
    abcorr = &#39;LT+S&#39;
    observer = &#39;MAVEN&#39;
    body = 499  # Mars IAU code

    for i in range(hifi_int):
        for j in range(hifi_spa):
            et = et_arr[i, j]
            los_mid = vec_arr[i, j, :]

            # try to perform the SPICE calculations and record the results
            # noinspection PyBroadException
            try:

                # calculate surface intercept
                spoint, trgepc, srfvec = spice.sincpt(&#39;Ellipsoid&#39;, target, et, frame, abcorr, observer, frame, los_mid)

                # calculate illumination angles
                trgepc, srfvec, phase_for, solar, emissn = spice.ilumin(&#39;Ellipsoid&#39;, target, et, frame, abcorr,
                                                                        observer, spoint)

                # convert from rectangular to spherical coordinates
                rpoint, colatpoint, lonpoint = spice.recsph(spoint)

                # convert longitude from domain [-pi,pi) to [0,2pi)
                if lonpoint &lt; 0.:
                    lonpoint += 2 * np.pi

                # convert ephemeris time to local solar time
                hr, mn, sc, time, ampm = spice.et2lst(et, body, lonpoint, &#39;planetocentric&#39;, timlen=256, ampmlen=256)

                # convert spherical coordinates to latitude and longitude in degrees
                latitude[i, j] = np.degrees(np.pi / 2 - colatpoint)
                longitude[i, j] = np.degrees(lonpoint)

                # convert illumination angles to degrees and record
                sza[i, j] = np.degrees(solar)
                phase_angle[i, j] = np.degrees(phase_for)
                emission_angle[i, j] = np.degrees(emissn)

                # convert local solar time to decimal hour
                local_time[i, j] = hr + mn / 60 + sc / 3600

                # convert latitude and longitude to pixel coordinates
                map_lat = int(np.round(np.degrees(colatpoint), 1) * 10)
                map_lon = int(np.round(np.degrees(lonpoint), 1) * 10)

                # instead of changing an alpha layer, I just multiply an RGB triplet by a scaling fraction in order to
                # make it darker; determine that scalar here based on solar zenith angle
                if twilight == &#39;discrete&#39;:
                    if (sza[i, j] &gt; 90) &amp; (sza[i, j] &lt;= 102):
                        twilight = 0.7
                    elif sza[i, j] &gt; 102:
                        twilight = 0.4
                    else:
                        twilight = 1
                else:
                    if (sza[i, j] &gt; 90) &amp; (sza[i, j] &lt;= 102):
                        tsza = (sza[i, j]-90)*np.pi/2/12
                        twilight = np.cos(tsza)*0.6 + 0.4
                    elif sza[i, j] &gt; 102:
                        twilight = 0.4
                    else:
                        twilight = 1

                # place the corresponding pixel from the high-resolution Mars map into the swath context map with the
                # twilight scaling
                context_map[i, j, :] = mars_surface_map[map_lat, map_lon, :] / 255 * twilight

            # if the SPICE calculation fails, this (probably) means it didn&#39;t intercept the planet
            except:
                pass

    # get mirror angles
    angles = hdul[&#39;integration&#39;].data[&#39;mirror_deg&#39;] * 2  # convert from mirror angles to FOV angles
    dang = np.diff(angles)[0]

    # create an meshgrid of angular coordinates for the high-resolution pixel edges
    x, y = np.meshgrid(np.linspace(0, slit_width_deg, hifi_spa + 1),
                       np.linspace(angles[0] - dang / 2, angles[-1] + dang / 2, hifi_int + 1))

    # calculate the angular separation between pixels
    dslit = slit_width_deg / hifi_spa

    # create an meshgrid of angular coordinates for the high-resolution pixel centers
    cx, cy = np.meshgrid(
        np.linspace(0 + dslit, slit_width_deg - dslit, hifi_spa),
        np.linspace(angles[0], angles[-1], hifi_int))

    # beta-flip the coordinate arrays if necessary
    if flipped:
        x = np.fliplr(x)
        y = (np.fliplr(y) - 90) / (-1) + 90
        cx = np.fliplr(cx)
        cy = (np.fliplr(cy) - 90) / (-1) + 90

    # convert longitude to [-180,180)
    longitude[np.where(longitude &gt; 180)] -= 360

    # return the geometry and coordinate arrays
    return latitude, longitude, sza, local_time, x, y, cx, cy, context_map</code></pre>
</details>
</dd>
<dt id="maven_iuvs.geometry.rotation_matrix"><code class="name flex">
<span>def <span class="ident">rotation_matrix</span></span>(<span>axis, theta)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the rotation matrix associated with counterclockwise rotation about the given axis by theta radians.
To transform a vector, calculate its dot-product with the rotation matrix.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>axis</code></strong> :&ensp;<code>3-element list, array,</code> or <code>tuple</code></dt>
<dd>The rotation axis in Cartesian coordinates. Does not have to be a unit vector.</dd>
<dt><strong><code>theta</code></strong> :&ensp;<code>float</code></dt>
<dd>The angle (in radians) to rotate about the rotation axis. Positive angles rotate counter-clockwise.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>array</code></dt>
<dd>The 3D rotation matrix with dimensions (3,3).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotation_matrix(axis, theta):
    &#34;&#34;&#34;
    Return the rotation matrix associated with counterclockwise rotation about the given axis by theta radians.
    To transform a vector, calculate its dot-product with the rotation matrix.

    Parameters
    ----------
    axis : 3-element list, array, or tuple
        The rotation axis in Cartesian coordinates. Does not have to be a unit vector.
    theta : float
        The angle (in radians) to rotate about the rotation axis. Positive angles rotate counter-clockwise.

    Returns
    -------
    matrix : array
        The 3D rotation matrix with dimensions (3,3).
    &#34;&#34;&#34;

    # convert the axis to a numpy array and normalize it
    axis = np.array(axis)
    axis = axis / np.linalg.norm(axis)

    # calculate components of the rotation matrix elements
    a = np.cos(theta / 2)
    b, c, d = -axis * np.sin(theta / 2)
    aa, bb, cc, dd = a * a, b * b, c * c, d * d
    bc, ad, ac, ab, bd, cd = b * c, a * d, a * c, a * b, b * d, c * d

    # build the rotation matrix
    matrix = np.array([[aa + bb - cc - dd, 2 * (bc + ad), 2 * (bd - ac)],
                       [2 * (bc - ad), aa + cc - bb - dd, 2 * (cd + ab)],
                       [2 * (bd + ac), 2 * (cd - ab), aa + dd - bb - cc]])

    # return the rotation matrix
    return matrix</code></pre>
</details>
</dd>
<dt id="maven_iuvs.geometry.spice_positions"><code class="name flex">
<span>def <span class="ident">spice_positions</span></span>(<span>et)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates MAVEN spacecraft position, Mars solar longitude, and subsolar position for a given ephemeris time.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>et</code></strong> :&ensp;<code>float</code></dt>
<dd>Input epoch in ephemeris seconds past J2000.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>et</code></strong> :&ensp;<code>array</code></dt>
<dd>The input ephemeris times. Just givin'em back.</dd>
<dt><strong><code>subsc_lat</code></strong> :&ensp;<code>array</code></dt>
<dd>Sub-spacecraft latitudes in degrees.</dd>
<dt><strong><code>subsc_lon</code></strong> :&ensp;<code>array</code></dt>
<dd>Sub-spacecraft longitudes in degrees.</dd>
<dt><strong><code>sc_alt_km</code></strong> :&ensp;<code>array</code></dt>
<dd>Sub-spacecraft altitudes in kilometers.</dd>
<dt><strong><code>ls</code></strong> :&ensp;<code>array</code></dt>
<dd>Mars solar longitudes in degrees.</dd>
<dt><strong><code>subsolar_lat</code></strong> :&ensp;<code>array</code></dt>
<dd>Sub-solar latitudes in degrees.</dd>
<dt><strong><code>subsolar_lon</code></strong> :&ensp;<code>array</code></dt>
<dd>Sub-solar longitudes in degrees.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spice_positions(et):
    &#34;&#34;&#34;
    Calculates MAVEN spacecraft position, Mars solar longitude, and subsolar position for a given ephemeris time.

    Parameters
    ----------
    et : float
        Input epoch in ephemeris seconds past J2000.

    Returns
    -------
    et : array
        The input ephemeris times. Just givin&#39;em back.
    subsc_lat : array
        Sub-spacecraft latitudes in degrees.
    subsc_lon : array
        Sub-spacecraft longitudes in degrees.
    sc_alt_km : array
        Sub-spacecraft altitudes in kilometers.
    ls : array
        Mars solar longitudes in degrees.
    subsolar_lat : array
        Sub-solar latitudes in degrees.
    subsolar_lon : array
        Sub-solar longitudes in degrees.
    &#34;&#34;&#34;

    # do a bunch of SPICE stuff only Justin understands...
    target = &#39;Mars&#39;
    abcorr = &#39;LT+S&#39;
    observer = &#39;MAVEN&#39;
    spoint, trgepc, srfvec = spice.subpnt(&#39;Intercept: ellipsoid&#39;, target, et, &#39;IAU_MARS&#39;, abcorr, observer)
    rpoint, colatpoint, lonpoint = spice.recsph(spoint)
    if lonpoint &gt; np.pi:
        lonpoint -= 2 * np.pi
    subsc_lat = 90 - np.degrees(colatpoint)
    subsc_lon = np.degrees(lonpoint)
    sc_alt_km = np.sqrt(np.sum(srfvec ** 2))

    # calculate subsolar position
    sspoint, strgepc, ssrfvec = spice.subslr(&#39;Intercept: ellipsoid&#39;, target, et, &#39;IAU_MARS&#39;, abcorr, observer)
    srpoint, scolatpoint, slonpoint = spice.recsph(sspoint)
    if slonpoint &gt; np.pi:
        slonpoint -= 2 * np.pi
    subsolar_lat = 90 - np.degrees(scolatpoint)
    subsolar_lon = np.degrees(slonpoint)

    # calculate solar longitude
    ls = spice.lspcn(target, et, abcorr)
    ls = np.degrees(ls)

    # return the position information
    return et, subsc_lat, subsc_lon, sc_alt_km, ls, subsolar_lat, subsolar_lon</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="maven_iuvs" href="index.html">maven_iuvs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="maven_iuvs.geometry.beta_flip" href="#maven_iuvs.geometry.beta_flip">beta_flip</a></code></li>
<li><code><a title="maven_iuvs.geometry.find_maven_apsis" href="#maven_iuvs.geometry.find_maven_apsis">find_maven_apsis</a></code></li>
<li><code><a title="maven_iuvs.geometry.get_orbit_positions" href="#maven_iuvs.geometry.get_orbit_positions">get_orbit_positions</a></code></li>
<li><code><a title="maven_iuvs.geometry.haversine" href="#maven_iuvs.geometry.haversine">haversine</a></code></li>
<li><code><a title="maven_iuvs.geometry.highres_swath_geometry" href="#maven_iuvs.geometry.highres_swath_geometry">highres_swath_geometry</a></code></li>
<li><code><a title="maven_iuvs.geometry.rotation_matrix" href="#maven_iuvs.geometry.rotation_matrix">rotation_matrix</a></code></li>
<li><code><a title="maven_iuvs.geometry.spice_positions" href="#maven_iuvs.geometry.spice_positions">spice_positions</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>